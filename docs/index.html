<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Onboard Player With MetaMask Only</title>
  <!-- Ethers.js (UMD build) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.5/ethers.umd.min.js"></script>
</head>
<body>
  <h1>Onboard Player</h1>

  <button id="connectButton">Connect MetaMask</button>
  <p id="walletStatus">Not connected</p>

  <hr />

  <label for="playerName">Player Name:</label>
  <input type="text" id="playerName" placeholder="Enter your desired name" />
  <button id="onboardButton">Onboard</button>
  <p id="onboardStatus"></p>

  <hr />

  <h2>Your Grens Balance</h2>
  <p id="balanceDisplay">Loading...</p>
  <button id="refreshBalanceButton">Refresh Balance</button>

  <script>
    /************************************************************
     *  Contract Addresses / ABIs
     ************************************************************/
    // The main DApp contract that has onboardPlayerGated(_playerName)
    const DAPP_CONTRACT_ADDRESS = "0xBd886d5E326d101Da3035E49F78c83d80dfFB4b2";
    // Minimal ABI for your function:
    const DAPP_CONTRACT_ABI = [
      "function onboardPlayerGated(string calldata _playerName) external"
    ];

    // The ERC20 "Grens" token contract
    const GRENS_CONTRACT_ADDRESS = "0x31e4f69cb2045314D9f9cD1cBA1A2137cB258dE3";
    // Standard ERC20 ABI subset for balanceOf (and optionally decimals)
    const GRENS_CONTRACT_ABI = [
      "function balanceOf(address owner) view returns (uint256)",
      "function decimals() view returns (uint8)"
    ];

    /************************************************************
     *  Global vars
     ************************************************************/
    let metamaskProvider;
    let ethersProvider;
    let signer;
    let userAddress = null;
    let dappContract;
    let grensContract;

    /************************************************************
     *  On page load, attach event listeners
     ************************************************************/
    window.addEventListener('load', () => {
      document.getElementById('connectButton').onclick = connectWallet;
      document.getElementById('onboardButton').onclick = onboardPlayer;
      document.getElementById('refreshBalanceButton').onclick = refreshBalance;
    });

    /************************************************************
     *  (A) pickMetaMaskProvider
     *  => ensures we only use the MetaMask provider if multiple
     ************************************************************/
    async function pickMetaMaskProvider() {
      if (!window.ethereum) {
        console.log("No window.ethereum found => no EVM provider");
        return null;
      }

      // If multiple providers exist
      if (window.ethereum.providers?.length) {
        // find the one with isMetaMask
        const providerArr = window.ethereum.providers;
        const metaMask = providerArr.find((p) => p.isMetaMask);
        if (metaMask) return metaMask;
      }

      // If there's only one provider (or no providers array), check if it is metamask
      if (window.ethereum.isMetaMask) {
        return window.ethereum;
      }

      // Otherwise, no metamask found
      return null;
    }

    /************************************************************
     *  (B) connectWallet => metaMask only
     ************************************************************/
    async function connectWallet() {
      const walletStatusEl = document.getElementById('walletStatus');
      try {
        metamaskProvider = await pickMetaMaskProvider();
        if (!metamaskProvider) {
          walletStatusEl.textContent = "MetaMask not found or Phantom overriding. Disable Phantom or ensure isMetaMask is present.";
          return;
        }

        // Request accounts
        await metamaskProvider.request({ method: 'eth_requestAccounts' });

        // Wrap in Ethers.js
        ethersProvider = new ethers.providers.Web3Provider(metamaskProvider);
        signer = ethersProvider.getSigner();
        userAddress = await signer.getAddress();
        walletStatusEl.textContent = "Connected to MetaMask as " + userAddress;

        // Initialize contract instances
        dappContract = new ethers.Contract(DAPP_CONTRACT_ADDRESS, DAPP_CONTRACT_ABI, signer);
        grensContract = new ethers.Contract(GRENS_CONTRACT_ADDRESS, GRENS_CONTRACT_ABI, ethersProvider);

        // Optionally show initial balance
        await refreshBalance();
      } catch (err) {
        console.error(err);
        walletStatusEl.textContent = "Connection failed: " + (err.message || err);
      }
    }

    /************************************************************
     *  (C) Onboard Player
     ************************************************************/
    async function onboardPlayer() {
      if (!dappContract || !signer) {
        alert("Please connect MetaMask first.");
        return;
      }
      const playerName = document.getElementById('playerName').value.trim();
      if (!playerName) {
        alert("Please enter a player name.");
        return;
      }

      const onboardStatusEl = document.getElementById('onboardStatus');
      onboardStatusEl.textContent = "Sending transaction...";

      try {
        const tx = await dappContract.onboardPlayerGated(playerName);
        onboardStatusEl.textContent = "Waiting for confirmation (tx: " + tx.hash + ")...";
        const receipt = await tx.wait();
        onboardStatusEl.textContent = "Success! Player onboarded in block " + receipt.blockNumber;

        // Optionally refresh balance after onboard
        await refreshBalance();
      } catch (err) {
        console.error(err);
        onboardStatusEl.textContent = "Error: " + (err.message || err);
      }
    }

    /************************************************************
     *  (D) Refresh Token Balance
     ************************************************************/
    async function refreshBalance() {
      const balanceEl = document.getElementById('balanceDisplay');
      if (!userAddress || !grensContract) {
        balanceEl.textContent = "Not connected.";
        return;
      }

      try {
        const balanceBN = await grensContract.balanceOf(userAddress);
        // If token has decimals:
        // const decimals = await grensContract.decimals();
        // const balanceStr = ethers.utils.formatUnits(balanceBN, decimals);
        const balanceStr = balanceBN.toString(); // raw integer if ignoring decimals
        balanceEl.textContent = balanceStr + " GRENS";
      } catch (err) {
        console.error(err);
        balanceEl.textContent = "Error fetching balance: " + (err.message || err);
      }
    }
  </script>
</body>
</html>
