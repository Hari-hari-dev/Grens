<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Onboard Player</title>
  <!-- Load Ethers.js (UMD build) -->
  <script src="https://hari-hari-dev.github.io/Grens/ethers-5.2.umd.min.js"></script>
</head>
<body>
  <h1>Onboard Player to DApp</h1>

  <!-- 1) Connect wallet -->
  <button id="connectButton">Connect Wallet</button>
  <p id="walletStatus">Not connected</p>

  <hr />

  <!-- 2) Onboard Player -->
  <label for="playerName">Player Name:</label>
  <input type="text" id="playerName" placeholder="Enter your desired name" />
  <button id="onboardButton">Onboard</button>

  <!-- 3) Confirm Name (Name->Address) -->
  <button id="checkNameButton">Confirm Name</button>

  <!-- 4) Check Registered Name => Address->Name (using userAddress) -->
  <button id="checkRegisteredNameButton">Check Registered Name</button>

  <p id="onboardStatus"></p>

  <hr />

  <h2>Your Grens Balance</h2>
  <p id="balanceDisplay">Loading...</p>
  <button id="refreshBalanceButton">Refresh Balance</button>

  <script>
    /************************************************************
     *  Contract Addresses / ABIs
     ************************************************************/
    const DAPP_CONTRACT_ADDRESS = "0x06D110905E3cF4200cD71768877158df2bcFEC20";
    // The contract now returns two values from the lookups:
    // getAddressByName(_playerName) => (address gatingAddr, bool passOk)
    // getNameByAddress(addr)        => (string playerName, bool passOk)
    const DAPP_CONTRACT_ABI = [
      "function onboardPlayerGated(string calldata _playerName) external",
      "function getAddressByName(string calldata) external view returns (address, bool)",
      "function getNameByAddress(address) external view returns (string memory, bool)"
    ];

    // The ERC20 "Grens" token contract
    const GRENS_CONTRACT_ADDRESS = "0x75CaC475933142d6870b465443c98E84A7aA7F84";
    // Standard ERC20 ABI subset for balanceOf & decimals
    const GRENS_CONTRACT_ABI = [
      "function balanceOf(address owner) view returns (uint256)",
      "function decimals() view returns (uint8)"
    ];

    /************************************************************
     *  Global vars for Ethers
     ************************************************************/
    let provider;
    let signer;
    let dappContract;
    let grensContract;
    let userAddress = null;

    /************************************************************
     *  On page load, set up button event listeners
     ************************************************************/
    window.addEventListener('load', function () {
      document.getElementById('connectButton').onclick            = connectWallet;
      document.getElementById('onboardButton').onclick            = onboardPlayer;
      document.getElementById('checkNameButton').onclick          = checkName;
      document.getElementById('checkRegisteredNameButton').onclick = checkRegisteredName;
      document.getElementById('refreshBalanceButton').onclick     = refreshBalance;
    });

    /************************************************************
     *  (A) pickMetaMaskProvider => ensure we only use MetaMask
     ************************************************************/
    async function pickMetaMaskProvider() {
      // If no EVM provider at all:
      if (!window.ethereum) {
        return null;
      }

      // If multiple providers exist:
      if (window.ethereum.providers?.length) {
        // find the one with isMetaMask
        const metaMask = window.ethereum.providers.find((p) => p.isMetaMask);
        if (metaMask) return metaMask;
      }

      // If there's only one provider or no .providers array, check if it's MetaMask
      if (window.ethereum.isMetaMask) {
        return window.ethereum;
      }

      // Otherwise, no metamask
      return null;
    }

    /************************************************************
     *  1) Connect to MetaMask only
     ************************************************************/
    async function connectWallet() {
      if (!window.ethereum) {
        alert("No EVM provider found. Please install MetaMask.");
        return;
      }

      try {
        const metaMaskProvider = await pickMetaMaskProvider();
        if (!metaMaskProvider) {
          alert("MetaMask not found or Phantom is overriding. Please disable Phantom or ensure isMetaMask is present.");
          return;
        }

        // Request accounts from the chosen MetaMask provider
        await metaMaskProvider.request({ method: 'eth_requestAccounts' });

        // Wrap in Ethers.js
        provider = new ethers.providers.Web3Provider(metaMaskProvider);
        signer = provider.getSigner();
        userAddress = await signer.getAddress();

        document.getElementById('walletStatus').textContent =
          "Connected as " + userAddress;

        // Initialize contract instances
        dappContract = new ethers.Contract(DAPP_CONTRACT_ADDRESS, DAPP_CONTRACT_ABI, signer);
        grensContract = new ethers.Contract(GRENS_CONTRACT_ADDRESS, GRENS_CONTRACT_ABI, provider);

        // Optionally display initial balance
        await refreshBalance();
      } catch (err) {
        console.error(err);
        document.getElementById('walletStatus').textContent = "Connection failed: " + (err.message || err);
      }
    }

    /************************************************************
     *  2) Onboard Player
     ************************************************************/
    async function onboardPlayer() {
      if (!signer || !dappContract) {
        alert("Please connect your wallet first.");
        return;
      }
      const playerName = document.getElementById('playerName').value.trim();
      if (!playerName) {
        alert("Please enter a valid player name.");
        return;
      }

      const statusEl = document.getElementById('onboardStatus');
      statusEl.textContent = "Submitting transaction...";

      try {
        let tx = await dappContract.onboardPlayerGated(playerName);
        statusEl.textContent = "Waiting for confirmation (tx: " + tx.hash + ")...";
        let receipt = await tx.wait();  // Wait for block confirmation
        statusEl.textContent = `Success! Player onboarded. (block: ${receipt.blockNumber})`;

        // Optionally refresh balance
        await refreshBalance();
      } catch (err) {
        console.error("onboardPlayer error =>", err);
        handleContractError(err, "onboardStatus");
      }
    }

    /************************************************************
     *  2.5) checkName => Name -> (address, bool passOk)
     ************************************************************/
    async function checkName() {
      if (!dappContract) {
        alert("Please connect your wallet first.");
        return;
      }
      const playerName = document.getElementById('playerName').value.trim();
      if (!playerName) {
        alert("Please enter a valid player name.");
        return;
      }

      const statusEl = document.getElementById('onboardStatus');
      statusEl.textContent = "Checking name...";

      try {
        // Since getAddressByName now returns (address gatingAddr, bool passOk)
        const [gatingAddr, passOk] = await dappContract.getAddressByName(playerName);

        if (gatingAddr === ethers.constants.AddressZero) {
          statusEl.textContent = "Name not found in database.";
        } else {
          let passMsg = passOk ? "Civic uniqueness pass OK" : "Civic uniqueness pass invalid";
          if (userAddress && gatingAddr.toLowerCase() === userAddress.toLowerCase()) {
            statusEl.textContent = `Name in DB => ${gatingAddr} (this matches your wallet). ${passMsg}`;
          } else {
            statusEl.textContent = `Name in DB => ${gatingAddr}. ${passMsg}`;
          }
        }
      } catch (err) {
        console.error("checkName error =>", err);
        handleContractError(err, "onboardStatus");
      }
    }

    /************************************************************
     *  2.6) checkRegisteredName => uses userAddress -> (string memory, bool passOk)
     ************************************************************/
    async function checkRegisteredName() {
      const statusEl = document.getElementById('onboardStatus');
      // Must have a connected wallet & dappContract
      if (!userAddress) {
        statusEl.textContent = "Wallet not connected.";
        return;
      }
      if (!dappContract) {
        alert("Please connect your wallet first.");
        return;
      }

      statusEl.textContent = "Checking your registered name...";

      try {
        // getNameByAddress returns (string playerName, bool passOk)
        const [playerName, passOk] = await dappContract.getNameByAddress(userAddress);

        if (!playerName || playerName.length === 0) {
          statusEl.textContent = "No name found for your address.";
        } else {
          let passMsg = passOk ? "Civic uniqueness pass OK" : "Civic uniqueness pass invalid";
          statusEl.textContent = `Your address => name is "${playerName}". ${passMsg}`;
        }
      } catch (err) {
        console.error("checkRegisteredName error =>", err);
        handleContractError(err, "onboardStatus");
      }
    }

    /************************************************************
     *  3) Refresh Grens Token Balance
     ************************************************************/
    async function refreshBalance() {
      if (!userAddress || !grensContract) {
        document.getElementById('balanceDisplay').textContent = "Not connected.";
        return;
      }
      try {
        let balanceBN = await grensContract.balanceOf(userAddress);
        let decimals = await grensContract.decimals();
        let balanceStr = ethers.utils.formatUnits(balanceBN, decimals);

        document.getElementById('balanceDisplay').textContent =
          balanceStr + " GRENS";
      } catch (err) {
        console.error(err);
        document.getElementById('balanceDisplay').textContent =
          "Error fetching balance: " + (err.message || err);
      }
    }

    /************************************************************
     *  handleContractError => parse known revert messages
     ************************************************************/
    function handleContractError(err, elementId) {
      const statusEl = document.getElementById(elementId);
      let fallbackMsg = err.message || "execution reverted.";
      const errorMsg = fallbackMsg.toLowerCase();

      // Match on known revert strings
      if (errorMsg.includes("invalid gateway token")) {
        statusEl.textContent = "Error: You do not have a valid gateway token.";
      } else if (errorMsg.includes("address already onboarded")) {
        statusEl.textContent = "Error: This address is already onboarded!";
      } else if (errorMsg.includes("name already in use")) {
        statusEl.textContent = "Error: That name is already taken!";
      } else {
        statusEl.textContent = "Error: " + fallbackMsg;
      }
    }
  </script>
</body>
</html>
